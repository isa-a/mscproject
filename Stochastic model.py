#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Jun 10 15:42:48 2020

@author: isa
"""

#stochastic forms

#Br - resident duplication
#Bc - challenger duplication
#Dr - resident cell death
#Cr - challenger cell death


# dR = (Br - Dr)dt + (sqrt(Br + Dr))dW(t)
# dC = (Bc - Dc)dt + (sqrt(Bc + Dc))dW(t)

from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt
from numpy import *
import numpy as np
import gillespy2
from sdeint import *
from numba import jit

###############################################################################
#gillespie



@jit(nopython=True)#increase speed of function
def gillespy(Tinit, Tmax, R, C, K, rR, rC, alphaRC, alphaCR): #function with args
    ta = []
    Ra = []
    Ca = [] #empty lists to append to

    t = 0
    R = R
    C = C 
    
    while (t < Tmax - Tinit): #time step to integrate over
        ta.append(t)
        Ra.append(R)
        Ca.append(C)#adding to lists

        Br = rR * R
        Bc = rC * C
        Dr = rR/K * R * (R + alphaRC * C)
        Dc = rC/K * C * (C + alphaCR * R) #defining probabilities 

        R_sum = Br + Bc + Dr + Dc
        if (R_sum == 0): #if the population size is zero nothing will happen/can be done, so we must ensure the system ends if it is somehow zero
            break
        value1 = random.random()#generate random time 
        t += -log(value1)/R_sum

        value2 = random.random()#generate random population
        if (value2 < Br/R_sum):
            R += 1
        elif (value2 > Br/R_sum and value2 < (Br + Dr)/R_sum):
            R -= 1
        elif (value2 > (Br + Dr)/R_sum and value2 < (Br + Dr + Bc)/R_sum):
            C += 1
        else:
            C -= 1

    ta = [t + Tinit for t in ta]
    return(ta, Ra, Ca)


#timestep = [0,100]
#popsizes = [100,500]
#carryingcap = [1000]
#growthterms = [1.032,1.032]
#alphaterms = [1.5,1.3]    




def plotgillespie():
    results = gillespy(0,100,100,500,1000,1.032,1.032,1.3,0.3)#storing the model
    
    
    pops = np.transpose(np.array([results[1], results[2]]))#writing results as a matrix
    
    plt.plot(results[0], pops)#plotting
    plt.ylim(0,(max(results[2])))#adjusting axis
    plt.title('Stochastic System')
    plt.xlabel('Time')
    plt.ylabel('Population')
    plt.legend(['R', 'C'])

    #np.array([results[1], results[2]]).shape
plotgillespie()

###############################################################################
#tau leaping


@jit(nopython=True)
def tauleap(T_init, T_max, Res, Chal, K, r_res, r_chal, alphaRC, alphaCR, tau):#function make with tau
    ta = []
    Ra = []
    Ca = [] #lists to append to 

    t = 0
    R = Res
    C = Chal
    while (t < T_max - T_init):
        ta.append(t)
        Ra.append(R)
        Ca.append(C)#iteratively adding to each list

        Br = r_res * R
        Bc = r_chal * C
        Dr = r_res/K * R * (R + alphaRC * C)
        Dc = r_chal/K * C * (C + alphaCR * R)#all probabilities 

        # Constant step sizes. Choose to be small
        t += tau
        #t = t + tau

        # Choose tau based on Cao et al 2005. Or use max rate from theory (rK/4)
        # tau = epsilon / max(B_R, B_C, D_R, D_C)

        # Rates, Poisson distributed. First term is 'birth', second is 'death'
        R += (np.random.poisson(Br * tau, 1) - np.random.poisson(Dr * tau, 1))[0]
        C += (np.random.poisson(Bc * tau, 1) - np.random.poisson(Dc * tau, 1))[0] #taking difference of values generated by a poisson distribution for each pop.

        if R < 0:
            R = 0
        if C < 0:
            C = 0 #setting pops to 0 in case of negative values (not possible)

    ta = [t + T_init for t in ta]
    return(ta, Ra, Ca)


tauplot = tauleap(0, 100, 10, 1000, 1000, 1.032, 1.032, 1, 1, 1)


taupops = np.transpose(np.array([tauplot[1], tauplot[2]]))

plt.plot(tauplot[0], taupops)
plt.ylim(0,(max(results[2])))








###############################################################################
#tau leaping for N species


N = 3

@jit(nopython=True)
def tauNspecies(N, T_init, T_max, Chal, K, r_chal, alpha, tau):#function make with tau
    ta = []
    Ca = [] #lists to append to 

    t = 0
    for i in range(N):
        C = Chal[i]
    
    while (t < T_max - T_init):
        
        for i in range(N):
            for j in range(N):
                Bc = r_chal[j] * C[j]
            sum = 0
            for x in range (N):
                sum += alpha[x,i] * C[x]
            for k in range(N):
                Dc = r_chal[k]/K * C[k] * (C[k] + sum)#all probabilities 
        C += (np.random.poisson(Bc * tau, 1) - np.random.poisson(Dc * tau, 1))[0] 
           
       
        ta.append(t)
        Ca.append(C)#iteratively adding to each list

        #Bc = r_chal * C
        #Dc = r_chal/K * C * (C + alphaCR * R)#all probabilities 

        # Constant step sizes. Choose to be small
        t += tau
        #t = t + tau


        if C < 0:
            C = 0 #setting pops to 0 in case of negative values (not possible)

    ta = [t + T_init for t in ta]
    return(ta, Ca)


tauNspecies(3, 0.5, 0.73, 10, 1000, 1000, 1.032, 1.032, 1, 1, 0.09)












































def gillespie(Time, Populations, K, Growth, Alphas): #function with args
    ta = []
    Ra = []
    Ca = [] #empty lists to append to

    t = 0
    R = Populations[0]
    C = Populations[1] 
    
    while (t < Time[1] - Time[0]): #time step to integrate over
        ta.append(t)
        Ra.append(R)
        Ca.append(C)

        Br = Growth[0] * Populations[0]
        Bc = Growth[1] * Populations[1]
        Dr = Growth[0]/K * Populations[0] * (Populations[0] + Alphas[0] * Populations[1])
        Dc = Growth[1]/K * Populations[1] * (Populations[1] + Alphas[1] * Populations[0]) #defining probabilities 

        R_sum = Br + Bc + Dr + Dc
        if (R_sum == 0): #if the population size is zero nothing will happen/can be done, so we must ensure the system ends if it is somehow zero
            break
        value1 = random.random()
        t += -log(value1)/R_sum

        value2 = random.random()
        if (value2 < Br/R_sum):
            R += 1
        elif (value2 > Br/R_sum and value2 < (Br + Dr)/R_sum):
            R -= 1
        elif (value2 > (Br + Dr)/R_sum and value2 < (Br + Dr + Bc)/R_sum):
            C += 1
        else:
            C -= 1

    ta = [t + Time[0] for t in ta]
    return(ta, Ra, Ca)


Time = [0,100]
Populations = [100,500]
K = [1000]
Growth = [1.032,1.032]
Alphas = [1.5,1.3]    

Time = np.asarray(Time)
Populations = np.asarray(Populations)
K = np.asarray(K)
Growth = np.asarray(Growth)
Alphas = np.asarray(Alphas)


model = gillespie(Time, Populations, K, Growth, Alphas)



gilpop = np.transpose(np.array([model[1], model[2]]))
gilpop.shape
plt.plot(model[0], model[1])
plt.ylim(0,(max(results[2])))


len(results[2])

np.array([results[1], results[2]]).shape
