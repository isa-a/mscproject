#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Jun 10 15:42:48 2020

@author: isa
"""

#stochastic forms

#Br - resident duplication
#Bc - challenger duplication
#Dr - resident cell death
#Cr - challenger cell death


# dR = (Br - Dr)dt + (sqrt(Br + Dr))dW(t)
# dC = (Bc - Dc)dt + (sqrt(Bc + Dc))dW(t)

from scipy.integrate import solve_ivp
import matplotlib.pyplot as plt
from numpy import *
import numpy as np
import gillespy2
from sdeint import *
from numba import jit

###############################################################################
#gillespie



@jit(nopython=True)
def gillespy(Tinit, Tmax, R, C, K, rR, rC, alphaRC, alphaCR): #function with args
    ta = []
    Ra = []
    Ca = [] #empty lists to append to

    t = 0
    R = R
    C = C 
    
    while (t < Tmax - Tinit): #time step to integrate over
        ta.append(t)
        Ra.append(R)
        Ca.append(C)

        Br = rR * R
        Bc = rC * C
        Dr = rR/K * R * (R + alphaRC * C)
        Dc = rC/K * C * (C + alphaCR * R) #defining probabilities 

        R_sum = Br + Bc + Dr + Dc
        if (R_sum == 0): #if the population size is zero nothing will happen/can be done, so we must ensure the system ends if it is somehow zero
            break
        value1 = random.random()
        t += -log(value1)/R_sum

        value2 = random.random()
        if (u2 < Br/R_sum):
            R += 1
        elif (u2 > Br/R_sum and u2 < (Br + Dr)/R_sum):
            R -= 1
        elif (u2 > (Br + Dr)/R_sum and u2 < (Br + Dr + Bc)/R_sum):
            C += 1
        else:
            C -= 1

    ta = [t + t_init for t in ta]
    return(ta, Ra, Ca)
    
    
    
gillespy(0.5, 0.73, 10, 1000, 1000, 1.032, 1.032, 1, 1)








###############################################################################
#tau leaping


@jit(nopython=True)
def tauleap(T_init, T_max, Res, Chal, K, r_res, r_chal, alphaRC, alphaCR, tau):#function make with tau
    ta = []
    Ra = []
    Ca = [] #lists to append to 

    t = 0
    R = Res
    C = Chal
    while (t < T_max - T_init):
        ta.append(t)
        Ra.append(R)
        Ca.append(C)#iteratively adding to each list

        Br = r_res * R
        Bc = r_chal * C
        Dr = r_res/K * R * (R + alphaRC * C)
        Dc = r_chal/K * C * (C + alphaCR * R)#all probabilities 

        # Constant step sizes. Choose to be small
        t += tau
        #t = t + tau

        # Choose tau based on Cao et al 2005. Or use max rate from theory (rK/4)
        # tau = epsilon / max(B_R, B_C, D_R, D_C)

        # Rates, Poisson distributed. First term is 'birth', second is 'death'
        R += (np.random.poisson(Br * tau, 1) - np.random.poisson(Dr * tau, 1))[0]
        C += (np.random.poisson(Bc * tau, 1) - np.random.poisson(Dc * tau, 1))[0] #taking difference of values generated by a poisson distribution for each pop.

        if R < 0:
            R = 0
        if C < 0:
            C = 0 #setting pops to 0 in case of negative values (not possible)

    ta = [t + T_init for t in ta]
    return(ta, Ra, Ca)


tauleap(0.5, 0.73, 10, 1000, 1000, 1.032, 1.032, 1, 1, 0.09)










###############################################################################
#tau leaping for N species


N = 3

@jit(nopython=True)
def tauNspecies(T_init, T_max, Chal, K, r_chal, alpha, tau):#function make with tau
    ta = []
    Ca = [] #lists to append to 

    t = 0
    C = Chal
    
    while (t < T_max - T_init):
        
        for i in range(N):
            for j in range(N):
                Bc = r_chal[j] * C[j]
            sum = 0
            for x in range (N):
                sum += alpha[x,i] * C[x]
            for k in range(N):
                Dc = r_chal[k]/K * C[k] * (C[k] + sum)#all probabilities 
            
       
        ta.append(t)
        Ca.append(C)#iteratively adding to each list

        #Bc = r_chal * C
        #Dc = r_chal/K * C * (C + alphaCR * R)#all probabilities 

        # Constant step sizes. Choose to be small
        t += tau
        #t = t + tau

        C += (np.random.poisson(Bc * tau, 1) - np.random.poisson(Dc * tau, 1))[0] 

        if C < 0:
            C = 0 #setting pops to 0 in case of negative values (not possible)

    ta = [t + T_init for t in ta]
    return(ta, Ca)


tauNspecies(0.5, 0.73, 10, 1000, 1000, 1.032, 1.032, 1, 1, 0.09)




